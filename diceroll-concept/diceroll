use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};

/// A reusable percentage-chance betting engine for MutantRolls.
///
/// This module is written in idiomatic Rust + Anchor and is designed to be
/// integrated with the existing CLR staking program. In particular,
/// `vault_token_account` is intended to be the CLR vault PDA holding MUTR,
/// and all SPL transfers use `token::transfer` via CPI.

/// Check whether a random number results in a win for a given percentage.
///
/// - `randomness` is any u64 random value from an RNG.
/// - `chance_percent` is a value in [0, 100].
///
/// We compute `roll = (randomness % 100) + 1` (range [1, 100]) and return
/// true if `roll <= chance_percent`.
pub fn check_chance(randomness: u64, chance_percent: u64) -> bool {
    if chance_percent == 0 || chance_percent > 100 {
        return false;
    }
    let roll = (randomness % 100) + 1;
    roll <= chance_percent
}

// -------------------------------------------------------------------------
// Accounts
// -------------------------------------------------------------------------

/// On-chain representation of a single bet.
#[account]
pub struct Bet {
    /// Player who placed the bet.
    pub player: Pubkey,
    /// Amount of MUTR staked on this bet.
    pub amount: u64,
    /// Win chance in percent (1â€“100).
    pub chance_percent: u64,
    /// Resulting roll in [1, 100] once resolved.
    pub roll_result: u64,
    /// Whether the bet was won.
    pub win: bool,
    /// Whether this bet has already been resolved.
    pub settled: bool,
}

impl Bet {
    pub const LEN: usize = 32 // player
        + 8 // amount
        + 8 // chance_percent
        + 8 // roll_result
        + 1 // win
        + 1; // settled
}

/// Accounts for placing a bet.
///
/// This transfers MUTR from the player to the vault and records the bet
/// in a PDA account.
#[derive(Accounts)]
#[instruction(bet_id: u64)]
pub struct PlaceBet<'info> {
    /// Player placing the bet.
    #[account(mut)]
    pub player: Signer<'info>,

    /// Player's MUTR token account.
    #[account(
        mut,
        constraint = player_token_account.owner == player.key() @ DiceError::Unauthorized,
    )]
    pub player_token_account: Account<'info, TokenAccount>,

    /// Vault token account (intended to be the CLR MUTR vault PDA).
    ///
    /// We only require that it shares the same mint as the player's account.
    #[account(
        mut,
        constraint = vault_token_account.mint == player_token_account.mint @ DiceError::InvalidMint,
    )]
    pub vault_token_account: Account<'info, TokenAccount>,

    /// PDA that stores bet state for (player, bet_id).
    #[account(
        init,
        payer = player,
        space = 8 + Bet::LEN,
        seeds = [b"bet", player.key().as_ref(), bet_id.to_le_bytes().as_ref()],
        bump
    )]
    pub bet: Account<'info, Bet>,

    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

/// Accounts for resolving a bet.
///
/// This consumes RNG randomness, determines win/loss, optionally pays out
/// from the vault to the player, and marks the bet as settled so it
/// cannot be executed twice.
#[derive(Accounts)]
#[instruction(bet_id: u64)]
pub struct ResolveBet<'info> {
    /// Player who originally placed the bet.
    #[account(mut)]
    pub player: Signer<'info>,

    /// Player's MUTR token account.
    #[account(
        mut,
        constraint = player_token_account.owner == player.key() @ DiceError::Unauthorized,
    )]
    pub player_token_account: Account<'info, TokenAccount>,

    /// Vault token account (intended to be the CLR MUTR vault PDA).
    #[account(
        mut,
        constraint = vault_token_account.mint == player_token_account.mint @ DiceError::InvalidMint,
    )]
    pub vault_token_account: Account<'info, TokenAccount>,

    /// Existing bet PDA for (player, bet_id).
    #[account(
        mut,
        seeds = [b"bet", player.key().as_ref(), bet_id.to_le_bytes().as_ref()],
        bump,
        constraint = bet.player == player.key() @ DiceError::Unauthorized,
    )]
    pub bet: Account<'info, Bet>,

    /// Authority that controls the vault token account.
    ///
    /// In a direct CLR integration, this could be the CLR `state` PDA
    /// invoked via CPI from the CLR program.
    #[account(mut)]
    pub vault_authority: Signer<'info>,

    pub token_program: Program<'info, Token>,
}

// -------------------------------------------------------------------------
// Instructions
// -------------------------------------------------------------------------

/// Place a new bet.
///
/// - Initializes a `Bet` PDA keyed by `(player, bet_id)`.
/// - Transfers `amount` MUTR from `player_token_account` to `vault_token_account`.
/// - Records `player`, `amount`, and `chance_percent` on-chain.
pub fn place_bet(
    ctx: Context<PlaceBet>,
    bet_id: u64,
    amount: u64,
    chance_percent: u64,
) -> Result<()> {
    require!(amount > 0, DiceError::InvalidAmount);
    require!(
        chance_percent > 0 && chance_percent <= 100,
        DiceError::InvalidChance
    );

    let player = &ctx.accounts.player;
    let player_token_account = &ctx.accounts.player_token_account;
    let vault_token_account = &ctx.accounts.vault_token_account;

    // Transfer MUTR from the player to the vault.
    let cpi_accounts = Transfer {
        from: player_token_account.to_account_info(),
        to: vault_token_account.to_account_info(),
        authority: player.to_account_info(),
    };
    let cpi_ctx = CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);
    token::transfer(cpi_ctx, amount)?;

    // Initialize bet state.
    let bet = &mut ctx.accounts.bet;
    bet.player = player.key();
    bet.amount = amount;
    bet.chance_percent = chance_percent;
    bet.roll_result = 0;
    bet.win = false;
    bet.settled = false;

    Ok(())
}

/// Resolve an existing bet using RNG randomness.
///
/// - Computes `roll = (randomness % 100) + 1`.
/// - Determines win/loss via `check_chance`.
/// - If `won` and `payout_amount > 0`, transfers `payout_amount` MUTR
///   from the vault to the player, using `vault_authority` as SPL owner.
/// - Marks the bet as settled so it cannot be executed twice.
pub fn resolve_bet(
    ctx: Context<ResolveBet>,
    bet_id: u64,
    randomness: u64,
    payout_amount: u64,
) -> Result<()> {
    let bet = &mut ctx.accounts.bet;

    require!(!bet.settled, DiceError::AlreadySettled);

    // Compute roll and win/loss.
    let roll = (randomness % 100)
        .checked_add(1)
        .ok_or(DiceError::MathOverflow)?;

    let won = check_chance(randomness, bet.chance_percent);

    // Update bet state.
    bet.roll_result = roll;
    bet.win = won;
    bet.settled = true;

    // Optional payout from vault to player.
    if won && payout_amount > 0 {
        let vault = &ctx.accounts.vault_token_account;
        require!(
            payout_amount as u128 <= vault.amount as u128,
            DiceError::InsufficientVaultLiquidity
        );

        let cpi_accounts = Transfer {
            from: vault.to_account_info(),
            to: ctx.accounts.player_token_account.to_account_info(),
            authority: ctx.accounts.vault_authority.to_account_info(),
        };
        let cpi_ctx =
            CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts);
        token::transfer(cpi_ctx, payout_amount)?;
    }

    Ok(())
}

// -------------------------------------------------------------------------
// Errors
// -------------------------------------------------------------------------

#[error_code]
pub enum DiceError {
    #[msg("Invalid amount")]
    InvalidAmount,
    #[msg("Invalid chance percent")]
    InvalidChance,
    #[msg("Unauthorized")]
    Unauthorized,
    #[msg("Bet already settled")]
    AlreadySettled,
    #[msg("Insufficient vault liquidity for payout")]
    InsufficientVaultLiquidity,
    #[msg("Math overflow")]
    MathOverflow,
    #[msg("Invalid mint")]
    InvalidMint,
}
