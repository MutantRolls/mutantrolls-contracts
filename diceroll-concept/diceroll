use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};

/// A reusable basis-point (bps) chance betting engine for MutantRolls.
///
/// - Uses MUTR SPL tokens as the betting currency.
/// - Uses a CLR vault token account as the bankroll.
/// - Uses an RNG authority to resolve bets.
/// - Integrates with a simple `ClrState` account that tracks losses earmarked
///   for CLR rewards (hook point into the main CLR staking math).
///
/// Roll logic:
/// - `roll = (randomness % 10_000) + 1` in range [1, 10_000].
/// - `chance_bps` is in [1, 10_000] representing [0.01%, 100%].
/// - A bet wins if `roll <= chance_bps`.
///
/// Security:
/// - Vault authority is a program-derived address (PDA) with seeds
///   `[b"clr_vault_authority"]`.
/// - All transfers *from* the CLR vault use `CpiContext::new_with_signer` with
///   the PDA signer seeds.
/// - `resolve_bet` can only be called by the configured RNG authority stored
///   in `ClrState::authorized_rng`.
///   - On first use, the RNG authority is "registered" in `ClrState`.
///   - On subsequent uses, only that same authority is allowed to resolve bets.

/// Helper function to check win condition in basis points.
///
/// - `randomness`: any u64 random value from an RNG.
/// - `chance_bps`: value in [1, 10_000], representing 0.01%–100%.
pub fn check_chance(randomness: u64, chance_bps: u64) -> bool {
    if chance_bps == 0 || chance_bps > 10_000 {
        return false;
    }
    let roll = (randomness % 10_000) + 1;
    roll <= chance_bps
}

// -------------------------------------------------------------------------
// Accounts
// -------------------------------------------------------------------------

/// On-chain representation of a single dice bet.
///
/// Bets are created via `place_bet` and automatically closed (rent refunded
/// to the player) when resolved via `resolve_bet`.
#[account]
pub struct DiceBet {
    /// Player who placed the bet.
    pub player: Pubkey,
    /// Amount of MUTR staked on this bet.
    pub amount: u64,
    /// Win chance in basis points (1–10_000).
    pub chance_bps: u64,
    /// Resulting roll in [1, 10_000] once resolved.
    pub roll_result: u64,
    /// Whether the bet was won.
    pub win: bool,
    /// Actual payout amount transferred to the player on win.
    pub payout_amount: u64,
    /// Bump for the DiceBet PDA.
    pub bump: u8,
}

impl DiceBet {
    pub const LEN: usize = 32  // player
        + 8  // amount
        + 8  // chance_bps
        + 8  // roll_result
        + 1  // win
        + 8  // payout_amount
        + 1; // bump
}

/// Minimal CLR integration state used by DiceRoll.
///
/// This tracks:
/// - Which CLR vault token account is used as bankroll.
/// - Cumulative losses that should be turned into CLR rewards.
/// - Which RNG authority is allowed to resolve bets.
#[account]
pub struct ClrState {
    /// The CLR vault token account used as bankroll for DiceRoll.
    pub clr_vault: Pubkey,
    /// Total MUTR from losing bets earmarked for CLR rewards.
    /// (Hook this into CLR reward math in the main program.)
    pub pending_loss_for_rewards: u64,
    /// RNG authority allowed to resolve bets.
    pub authorized_rng: Pubkey,
    /// PDA bump for this ClrState (seeds = [b"clr_state"]).
    pub bump: u8,
}

impl ClrState {
    pub const LEN: usize = 32  // clr_vault
        + 8   // pending_loss_for_rewards
        + 32  // authorized_rng
        + 1;  // bump
}

/// Accounts for placing a bet.
///
/// This:
/// - Initializes a `DiceBet` PDA keyed by `(player, bet_id)`.
/// - Lazily initializes / validates the `ClrState` PDA.
/// - Transfers `amount` MUTR from `player_token_account` into the CLR vault.
#[derive(Accounts)]
#[instruction(bet_id: u64)]
pub struct PlaceBet<'info> {
    /// Player placing the bet.
    #[account(mut)]
    pub player: Signer<'info>,

    /// Player's MUTR token account.
    #[account(
        mut,
        constraint = player_token_account.owner == player.key() @ DiceError::Unauthorized,
    )]
    pub player_token_account: Account<'info, TokenAccount>,

    /// CLR vault token account holding MUTR used as bankroll.
    ///
    /// Must share the same mint as the player's account and be owned by the
    /// `vault_authority` PDA.
    #[account(
        mut,
        constraint = vault_token_account.mint == player_token_account.mint @ DiceError::InvalidMint,
        constraint = vault_token_account.owner == vault_authority.key() @ DiceError::InvalidVaultAuthority,
    )]
    pub vault_token_account: Account<'info, TokenAccount>,

    /// PDA that stores bet state for (player, bet_id).
    #[account(
        init,
        payer = player,
        space = 8 + DiceBet::LEN,
        seeds = [b"dice_bet", player.key().as_ref(), bet_id.to_le_bytes().as_ref()],
        bump,
    )]
    pub bet: Account<'info, DiceBet>,

    /// Global DiceRoll CLR integration state.
    ///
    /// On first use, this is initialized and pinned to the current
    /// `vault_token_account`.
    #[account(
        init_if_needed,
        payer = play
